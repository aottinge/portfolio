<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Projet 3 : Création d'un vocoder - Portfolio Axel</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="icon" type="image/png" href="../image/logo.png">
</head>
<body>
    <nav class="navbar">
        <ul>
            <li><a href="../index.html">Accueil</a></li>
            <li><a href="projets.html">Projets</a></li>
            <li><a href="../contact.html">Contact</a></li>
        </ul>
    </nav>
    <section class="section">
        <h2>Projet 3 : Création d'un vocoder</h2>
        <div class="texte">
            <p>
                <strong>Sujet :</strong> J'ai conçu un vocoder permettant de changer le son d'un audio donné selon l'envie de l'utilisateur. L'utilisateur pouvait choisir le facteur de dilatation du son pour transformer l'audio et écouter le résultat en temps réel.
            </p>
            <p>
                Ce projet m'a permis d'approfondir mes connaissances en Comparaison d'algorithme et en implémentation.
            </p>
            <hr class="separateur">
            <div class="figure">
                <img src="images/projet3/figure1.png" alt="Figure 1" />
                <figcaption>Figure 1: Implémentation d’une méthode de ré-échantillonnage avec interpolation en Java </figcaption>
                <div class="trace">
                    <p>
                        <strong>Trace :</strong> La Figure 1 présente un extrait de code Java implémentant une méthode resample, utilisée pour effectuer un ré-échantillonnage d’un tableau de données numériques (par exemple un signal audio). Le ré-échantillonnage consiste à modifier la fréquence d’un signal, soit pour le compresser (en diminuant le nombre de points), soit pour l’affiner (en ajoutant des points intermédiaires). Cette fonction, développée dans le cadre d’un projet en Java, constitue une illustration concrète de la mise en œuvre d’un algorithme simple de traitement du signal, avec un objectif de transformation mathématique appliquée à une structure de données
                    </p>
                    <p>
                        Le code repose sur un paramètre freqScale, qui indique le facteur de ré-échantillonnage à appliquer. Trois cas sont traités de façon distincte :
                    </p>
                    <ul>
                        <li>Si le facteur est égal à 1, la fonction renvoie une copie du signal d’origine, sans modification.</li>
                        <li>Si freqScale > 1, un sous-échantillonnage est effectué : l’algorithme sélectionne un échantillon tous les freqScale, ce qui réduit la taille du signal.</li>
                        <li>Si freqScale < 1, un sur-échantillonnage est réalisé via interpolation linéaire entre les valeurs : l’algorithme calcule de nouveaux points intermédiaires pour lisser le signal.</li>
                    </ul>
                    <p>
                        Cette figure permet de mettre en évidence plusieurs savoirs : la maîtrise de la gestion des erreurs avec IllegalArgumentException, la compréhension des opérations d’interpolation numérique, et la capacité à écrire un code structuré, clair et performant avec un traitement différencié selon les cas.
                    </p>
                    <p>
                        Elle témoigne également de savoir-faire pratiques importants, comme le contrôle précis des indices de tableau, l’usage combiné de types entiers et flottants, ainsi que la capacité à simplifier la complexité du traitement grâce à une structure conditionnelle bien organisée. Ce type d’implémentation constitue une base pertinente pour comparer différents algorithmes de traitement, en évaluant leur performance, leur fidélité au signal initial et leur coût algorithmique.
                    </p>
                </div>
            </div>
    </section>
    <footer>
        © 2024 Axel Ottinger — Portfolio | <a href="mailto:axelottinger1@gmail.com">Contact</a>
    </footer>
</body>
</html>